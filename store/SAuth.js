/**
 *    Store: SAuth
 *    Description: Manages user auth and logged in state.
 *
 *
 *  **THIS CODE WAS GENERATED BY A TOOL**
 * **eOcean vue nuxt generator
 *
 * This is an implementation of a simple generic store to provide
 * -CRUD
 * -get all
 * -search
 *
 * for a single dto (Schema1 in this case).
 * A test data json file is used to spoof a database for now but this would be
 * easily replaced by a mongo api/db.
 */

import displayDef from '@/store/display-schemas/SAuth.json'

export const state = () => ({
  schemaDisplayDefinition: displayDef,
  isLoggedIn: false, //True iff user is logged in
  loginAPIEndpoint: '/api/login', //The endpoint for the login api (i.e. /api/login)
})

export const getters = {
  schemaDisplayDefinition: (state) => state.schemaDisplayDefinition,
  isLoggedIn: (state) => state.isLoggedIn, //True iff user is logged in
  loginAPIEndpoint: (state) => state.loginAPIEndpoint, //The endpoint for the login api (i.e. /api/login)
}

export const actions = {
  update(ctx, data) {
    const updateLevel0 = (ctx, data) => {
      //FInd data in all by id then update.
      const hits = ctx.state.all.filter((f) => f.id == data.id)
      if (!hits)
        throw `Error: found 0 hits in all data collection for id (${data.id})`
      if (hits.length > 1)
        throw `Error: found multiple id's in all data collection for id (${data.id})`

      //Update data in all data for hit and fire mutation
      ctx.commit('update', { dataToUpdate: hits[0], newData: data })
    }

    if (!data.parentFieldName) {
      updateLevel0(ctx, data)
    } else {
      ctx.commit('updateNestedChild', data)
    }
  },
  /*logs the user in to db*/
  doLogin: (ctx, value) => {
    ctx.commit('isLoggedIn', true)
  },
  doLogout: (ctx, value) => {
    ctx.commit('isLoggedIn', false)
  },
}

export const mutations = {
  schemaDisplayDefinition: (state, value) =>
    (state.schemaDisplayDefinition = value),
  update(state, data) {
    data.dataToUpdate[data.newData.fieldDef.fieldName] = data.newData.newValue
  },
  updateNestedChild(state, data) {
    const updateLevelN = (state, data) => {
      const levels = data.parentFieldName.split('/')
      let currentObject = state.all
      let root
      for (let n = 0; n < levels.length; n++) {
        const levelToken = levels[n]

        /**Using level token
         * -if numeric then construe as an index lookup on current object
         * -if not numeric then construe as a property name on current object
         */
        //If we're at end of list then use this final token as setter
        if (n == levels.length - 1) {
          currentObject[levelToken] = data.newValue
        } else {
          if (!isNaN(levelToken)) {
            //Is numeric so do lookup on current object id using levelToken as id.
            const hit = currentObject.find((o) => o.id == levelToken)
            if (hit) {
              currentObject = hit
            }
          } else {
            currentObject = currentObject[levelToken]
          }
        }
      }
    }

    updateLevelN(state, data)
  },
  add(state, text) {
    all.list.push({
      text,
      done: false,
    })
  },
  remove(state, { todo }) {
    all.list.splice(state.list.indexOf(todo), 1)
  },
  isLoggedIn: (state, value) => {
    state.isLoggedIn = value
  }, //True iff user is logged in
  loginAPIEndpoint: (state, value) => (state.loginAPIEndpoint = value), //The endpoint for the login api (i.e. /api/login)
}
